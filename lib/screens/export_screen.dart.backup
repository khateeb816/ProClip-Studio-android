import 'dart:io';
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/ffmpeg_service.dart';
import '../services/titanium_service.dart';
import '../services/notification_service.dart';
import '../models/video_settings.dart';

class ExportScreen extends StatefulWidget {
  final List<File> videoFiles;
  final List<VideoSettings> videoSettings;
  
  // Global Settings
  final double clipDuration;
  final String? audioPath;
  final String audioMode;
  final int exportHeight;
  final int exportFps;
  final String aspectRatio;
  final int clipCount;
  final String fitMode;
  final bool isAutoClipCount;

  const ExportScreen({
    super.key,
    required this.videoFiles,
    required this.videoSettings,
    required this.clipDuration,
    required this.audioPath,
    required this.audioMode,
    required this.exportHeight,
    required this.exportFps,
    required this.aspectRatio,
    required this.clipCount,
    required this.fitMode,
    required this.isAutoClipCount,
  });

  @override
  State<ExportScreen> createState() => _ExportScreenState();
}

class _ExportScreenState extends State<ExportScreen> {
  int _currentVideoIndex = 0;
  int _currentClipIndex = 0;
  int _totalClipsForCurrentVideo = 0;
  double _currentVideoProgress = 0.0;
  double _currentClipProgress = 0.0;
  bool _isProcessing = false;
  bool _isComplete = false;
  
  // Replaced VideoPlayer with Thumbnail File
  File? _currentThumbnail;

  @override
  void initState() {
    super.initState();
    WakelockPlus.enable();
    FFMpegService.resetCancellation();
    FFMpegService.resetCancellation();
    
    // Listen to Native Engine Progress
    TitaniumService.onProgress.listen((progress) {
       print("ðŸ“Š Progress Event Received: $progress"); // DEBUG
       if (mounted && _isProcessing) {
          setState(() {
             _currentClipProgress = progress;
          });
          
          // Update notification with current progress
          final overallProgress = ((_currentVideoIndex + progress) / widget.videoFiles.length * 100).toInt();
          NotificationService.showProgress(
            overallProgress,
            message: "V${_currentVideoIndex + 1}: Clip ${_currentClipIndex}/${_totalClipsForCurrentVideo} (${(progress * 100).toInt()}%)"
          );
       }
    });

    _startBatchPipeline();
  }
  
  @override
  void dispose() {
    WakelockPlus.disable();
    super.dispose();
  }

  void _cancelExport() {
    FFMpegService.cancelExport();
    NotificationService.cancelAll();
    Navigator.pop(context);
  }

  Future<void> _startBatchPipeline() async {
    String? customPath;
    try {
      final prefs = await SharedPreferences.getInstance();
      customPath = prefs.getString('custom_output_path');
    } catch (_) {}
    
    final docDir = await getApplicationDocumentsDirectory();
    final outBaseDir = customPath ?? docDir.path;

    print("ðŸš€ Starting Zero Copy Pipeline for ${widget.videoFiles.length} videos");
    
    // Serial execution to protect Hardware Encoder resource
    // Queue is technically 1 concurency but we iterate serially here to be safe
    // and correctly update per-video UI.
    
    for (int i = 0; i < widget.videoFiles.length; i++) {
        if (!mounted) break;
        
        final file = widget.videoFiles[i];
        final settings = widget.videoSettings[i];
        
        setState(() {
          _currentVideoIndex = i;
          _isProcessing = true;
          _currentVideoProgress = 0.0;
          _currentClipIndex = 0;
          _currentThumbnail = null;
        });

        // 1. Generate Thumbnail (Fast, no player)
        FFMpegService.generateThumbnail(file.path).then((path) {
           if (mounted && path != null) {
              setState(() => _currentThumbnail = File(path));
           }
        });

        // 2. Metadata Scan
        double duration = settings.metadata?.duration ?? 0;
        if (duration == 0) {
           final meta = await FFMpegService.getVideoMetadata(file.path);
           duration = meta?.duration ?? 0;
        }

        if (duration <= 0) {
           print("âš ï¸ Skipping invalid duration: ${file.path}");
           continue; 
        }

        // 3. Generate Plan
        final plan = FFMpegService.generateClipPlan(
           totalDuration: duration,
           clipDuration: widget.clipDuration,
           count: widget.isAutoClipCount ? null : widget.clipCount
        );
        
        setState(() => _totalClipsForCurrentVideo = plan.length);

        // 4. Sequential Pipeline (Robust & Optimized)
        // We use enqueueJob to ensure max 1 HW encoder session at a time.
        for (int c = 0; c < plan.length; c++) {
            if (!mounted || FFMpegService.isCancelled) break;
            
            final clip = plan[c];
            final start = clip['start']!;
            final end = clip['end']!;
            final duration = end - start;
            
            final timestamp = DateTime.now().millisecondsSinceEpoch;
            final outPath = "$outBaseDir/clip_${i}_${c}_$timestamp.mp4";
            
            setState(() {
               _currentClipIndex = c + 1;
               _currentClipProgress = 0.0;
            });
            
            NotificationService.showProgress(
               (_currentVideoProgress * 100).toInt(), 
               message: "V${i+1}: Clip ${c+1}/${plan.length}"
            );

            // Execute via Queue (Sequential)
            final resultPath = await FFMpegService.enqueueJob(() async {
                String? resultPath;
                
                // TITANIUM ENGINE (Hybrid GPU)
                // Use Native Engine if scaling/cropping is needed (Zero Copy)
                bool useNative = settings.cropRect != null && 
                                 settings.cropRect != const Rect.fromLTWH(0,0,1,1) &&
                                 settings.audioPath == null; // Native engine audio is WIP
                                 
                if (useNative) {
                     print("ðŸš€ Using Titanium Engine (Native)");
                     
                     // Calculate Output Resolution
                     int outHeight = widget.exportHeight;
                     double ratio = 9/16; // Default
                     try {
                        final parts = widget.aspectRatio.split(":");
                        if (parts.length == 2) {
                           ratio = double.parse(parts[0]) / double.parse(parts[1]);
                        }
                     } catch(_) {}
                     
                     int outWidth = (outHeight * ratio).round();
                     // RESOLUTION ALIGNMENT (Hardware Safety)
                     // Ensure even dimensions to prevent MediaCodec crashes
                     if (outWidth % 2 != 0) outWidth--;
                     if (outHeight % 2 != 0) outHeight--;

                     resultPath = await TitaniumService.export(
                        sourcePath: file.path, 
                        destPath: outPath,
                        config: {
                          'cropX': settings.cropRect?.left ?? 0.0,
                          'cropY': settings.cropRect?.top ?? 0.0,
                          'cropW': settings.cropRect?.width ?? 1.0,
                          'cropH': settings.cropRect?.height ?? 1.0,
                          'width': outWidth,
                          'height': outHeight,
                        }
                     );
                }

                // Fallback to FFmpeg Smart Export
                if (resultPath == null) {
                    print("âš ï¸ Fallback to FFmpeg Smart Export");
                    
                    // Start a timer to simulate progress (since FFmpeg doesn't report real progress)
                    bool exportComplete = false;
                    final progressTimer = Timer.periodic(const Duration(milliseconds: 200), (timer) {
                      if (!mounted || exportComplete) {
                        timer.cancel();
                        return;
                      }
                      // Simulate progress from 0 to 0.95 over a conservative estimate
                      // Use 1.5x the clip duration as estimate to account for processing overhead
                      final elapsed = timer.tick * 200; // milliseconds
                      final estimatedDuration = duration * 1500; // 1.5x duration for conservative estimate
                      final simulatedProgress = (elapsed / estimatedDuration).clamp(0.0, 0.95);
                      
                      setState(() {
                        _currentClipProgress = simulatedProgress;
                      });
                      
                      final overallProgress = ((_currentVideoIndex + simulatedProgress) / widget.videoFiles.length * 100).toInt();
                      NotificationService.showProgress(
                        overallProgress,
                        message: "V${_currentVideoIndex + 1}: Clip ${_currentClipIndex}/${_totalClipsForCurrentVideo} (${(simulatedProgress * 100).toInt()}%)"
                      );
                    });
                    
                    resultPath = await FFMpegService.executeSmartExport(
                       inputPath: file.path, 
                       outputPath: outPath, 
                       start: start, 
                       duration: duration, 
                       settings: settings, 
                       outputHeight: widget.exportHeight
                    );
                    
                    exportComplete = true;
                    progressTimer.cancel();
                }
                return resultPath;
            });

            if (mounted && resultPath != null) {
               setState(() {
                  _currentClipProgress = 1.0;
                  _currentVideoProgress = (c + 1) / plan.length;
               });
               
               // Update notification to 100% for this clip
               final overallProgress = ((_currentVideoIndex + 1.0) / widget.videoFiles.length * 100).toInt();
               NotificationService.showProgress(
                 overallProgress,
                 message: "V${_currentVideoIndex + 1}: Clip ${_currentClipIndex}/${_totalClipsForCurrentVideo} (100%)"
               );
            } else {
               print("âŒ Clip Export Failed: Video $i Clip $c");
            }

                     resultPath = await TitaniumService.export(
                        sourcePath: file.path, 
                        destPath: outPath,
                        config: {
                          'cropX': settings.cropRect?.left ?? 0.0,
                          'cropY': settings.cropRect?.top ?? 0.0,
                          'cropW': settings.cropRect?.width ?? 1.0,
                          'cropH': settings.cropRect?.height ?? 1.0,
                          'width': outWidth,
                          'height': outHeight,
                        }
                     );
                }

                // Fallback to FFmpeg Smart Export
                if (resultPath == null) {
                    print("âš ï¸ Fallback to FFmpeg Smart Export");
                    
                    // Start a timer to simulate progress (since FFmpeg doesn't report real progress)
                    bool exportComplete = false;
                    final progressTimer = Timer.periodic(const Duration(milliseconds: 200), (timer) {
                      if (!mounted || exportComplete) {
                        timer.cancel();
                        return;
                      }
                      // Simulate progress from 0 to 0.95 over a conservative estimate
                      // Use 1.5x the clip duration as estimate to account for processing overhead
                      final elapsed = timer.tick * 200; // milliseconds
                      final estimatedDuration = duration * 1500; // 1.5x duration for conservative estimate
                      final simulatedProgress = (elapsed / estimatedDuration).clamp(0.0, 0.95);
                      
                      setState(() {
                        _currentClipProgress = simulatedProgress;
                      });
                      
                      final overallProgress = ((_currentVideoIndex + simulatedProgress) / widget.videoFiles.length * 100).toInt();
                      NotificationService.showProgress(
                        overallProgress,
                        message: "V${_currentVideoIndex + 1}: Clip ${_currentClipIndex}/${_totalClipsForCurrentVideo} (${(simulatedProgress * 100).toInt()}%)"
                      );
                    });
                    
                    resultPath = await FFMpegService.executeSmartExport(
                       inputPath: file.path, 
                       outputPath: outPath, 
                       start: start, 
                       duration: duration, 
                       settings: settings, 
                       outputHeight: widget.exportHeight
                    );
                    
                    exportComplete = true;
                    progressTimer.cancel();
                }
                return resultPath;
            });

            if (mounted && resultPath != null) {
               setState(() {
                  _currentClipProgress = 1.0;
                  _currentVideoProgress = (c + 1) / plan.length;
               });
               
               // Update notification to 100% for this clip
               final overallProgress = ((_currentVideoIndex + 1.0) / widget.videoFiles.length * 100).toInt();
               NotificationService.showProgress(
                 overallProgress,
                 message: "V${_currentVideoIndex + 1}: Clip ${_currentClipIndex}/${_totalClipsForCurrentVideo} (100%)"
               );
            } else {
               print("âŒ Clip Export Failed: Video $i Clip $c");
            }
        }

        // STABILIZATION DELAY: Allow Android MediaServer to release handles
        if (mounted) {
           int delayMs = 500;
           // Snapdragon 732 Thermal Protection
           // If batch is large (>5), pause for 2s every 3 clips to let CPU cool
           if (FFMpegService.isSnapdragon && plan.length > 5 && (c + 1) % 3 == 0) {
              print("â„ï¸ Thermal Cooldown (2s)...");
              delayMs = 2000;
           }
           await Future.delayed(Duration(milliseconds: delayMs));
        }

        // Periodic Cleanup
        if (c % 5 == 0) {
           await FFMpegService.freeResources();
        }
    }
    }

    if (mounted) {
      setState(() {
        _isProcessing = false;
        _isComplete = true;
      });
      NotificationService.showDone("Success");
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isComplete) {
       return Scaffold(
        backgroundColor: const Color(0xFF121212),
        body: Center(
           child: Column(
             mainAxisAlignment: MainAxisAlignment.center,
             children: [
                const Icon(Icons.check_circle, color: Colors.greenAccent, size: 80),
                const SizedBox(height: 20),
                const Text("Export Complete!", style: TextStyle(color: Colors.white, fontSize: 24)),
                const SizedBox(height: 40),
                ElevatedButton(
                  onPressed: () => Navigator.of(context).popUntil((r) => r.isFirst),
                  child: const Text("Done"),
                )
             ],
           ),
        ),
       );
    }

    return Scaffold(
      backgroundColor: const Color(0xFF121212),
      body: SafeArea(
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Text("High Speed Export", style: TextStyle(color: Colors.white, fontSize: 24, fontWeight: FontWeight.bold)),
              const SizedBox(height: 10),
              Text("Processing Video ${_currentVideoIndex + 1} of ${widget.videoFiles.length}", style: const TextStyle(color: Colors.cyanAccent)),
              const SizedBox(height: 40),
              
              // Thumbnail Container
              Container(
                width: 200, height: 200,
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.cyanAccent, width: 2),
                  borderRadius: BorderRadius.circular(12),
                  color: Colors.black,
                ),
                child: _currentThumbnail != null 
                    ? ClipRRect(
                        borderRadius: BorderRadius.circular(10),
                        child: Image.file(_currentThumbnail!, fit: BoxFit.cover),
                      )
                    : const Center(child: CircularProgressIndicator()),
              ),
              
              const SizedBox(height: 40),
              
              // Progress Bar
              SizedBox(
                 width: 200,
                 child: Column(
                   children: [
                      LinearProgressIndicator(value: _currentClipProgress, color: Colors.deepOrangeAccent, backgroundColor: Colors.grey[800]),
                      const SizedBox(height: 8),
                      Text("Clip ${_currentClipIndex} / $_totalClipsForCurrentVideo", style: const TextStyle(color: Colors.white70)),
                   ],
                 )
              ),
              
              const SizedBox(height: 40),
              ElevatedButton(
                onPressed: _cancelExport,
                style: ElevatedButton.styleFrom(backgroundColor: Colors.red.withValues(alpha: 0.2)),
                child: const Text("Cancel", style: TextStyle(color: Colors.red)),
              )
            ],
          ),
        ),
      ),
    );
  }
}
